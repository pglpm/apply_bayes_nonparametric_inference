* Variate info
** type
| Continuous (real)          |  0 | R |
| Binary                     |  2 | B |
| Categorical                |  3 | C |
| Discrete ordinal (integer) |  1 | I |
| Censored                   | -1 | D |

** transformation
| 0 | id     |
| 1 | log    |
| 2 | probit |

** min (theoretical)
** max (theoretical)

| Continuous (real)          | min | max |
| Binary                     | min | max |
| Categorical                | min | max |
| Discrete ordinal (integer) | min | max |
| Censored                   | min | max |


** left truncation
** right truncation

** location

*** Discrete ordinal (integer) variates are assumed to take on a set of equispaced values. These must be translated into:
- Ileft values in the MCMC algorithm: defining the left boundary of the interval corresponding to that value
- Iright values in the MCMC algorithm: ditto for the right boundary
- location & scale are chosen so as to obtain a range {0,...,N-1}:
- then
  Ileft = qnorm( pmax(0, round((x-loc)/sca))/N )
  Iright = qnorm( pmin(N, 1+round((x-loc)/sca))/N )

*** Categorical variates are assumed to take on a set of equispaced values
- location & scale are chosen so as to obtain a range {0,...,N-1}:
- then
  value = round((x-loc)/sca)+1

| Continuous (real)          | median |
| Binary                     | min    |
| Categorical                | min    |
| Discrete ordinal (integer) | min    |
| Censored                   | median |

** scale
| Continuous (real)          | IQR or MAD      |
| Binary                     | max-min         |
| Categorical                | (max-min)/(N-1) |
| Discrete ordinal (integer) | (max-min)/(N-1) |
| Censored                   | IQR or MAD      |


** min
|  0 | Continuous (real)            | min |
|  1 | Int discrete ordinal         | m   |
|  2 | Binary                       | 0   |
|  3 | Categorical                  | 1   |
| -1 | Continuous strictly positive | min |
| -2 | Continuous doubly bounded    | m   |

** max
|  0 | Continuous (real)            | max  |
|  1 | Int discrete ordinal         | M    |
|  2 | Binary                       | 1    |
|  3 | Categorical                  | M    |
| -1 | Continuous strictly positive | +Inf |
| -2 | Continuous doubly bounded    | M    |

** n
|  0 | Continuous (real)            | +Inf |
|  1 | Int discrete ordinal         |    N |
|  2 | Binary                       |    2 |
|  3 | Categorical                  |    N |
| -1 | Continuous strictly positive | +Inf |
| -2 | Continuous doubly bounded    |    p |

** plotmin
|  0 | Continuous (real)            | extended-min |
|  1 | Int discrete ordinal         | m            |
|  2 | Binary                       | 0            |
|  3 | Categorical                  | 1            |
| -1 | Continuous strictly positive | extended-min |
| -2 | Continuous doubly bounded    | m            |

** max
|  0 | Continuous (real)            | extended-max |
|  1 | Int discrete ordinal         | M            |
|  2 | Binary                       | 1            |
|  3 | Categorical                  | M            |
| -1 | Continuous strictly positive | extended-max |
| -2 | Continuous doubly bounded    | M            |

** mean
|  0 | Continuous (real)            |  0 |
|  1 | Int discrete ordinal         |  0 |
|  2 | Binary                       | NA |
|  3 | Categorical                  | NA |
| -1 | Continuous strictly positive |  0 |
| -2 | Continuous doubly bounded    |  0 |

** meanshape [EXCLUDED]
|  0 | Continuous (real)            | ...  |
|  1 | Int discrete ordinal         | +Inf |
|  2 | Binary                       | NA   |
|  3 | Categorical                  | NA   |
| -1 | Continuous strictly positive | ...  |
| -2 | Continuous doubly bounded    | +Inf |

** sd (must be squared for variance)
|  0 | Continuous (real)            | ... |
|  1 | Int discrete ordinal         | 7/8 |
|  2 | Binary                       | NA  |
|  3 | Categorical                  | NA  |
| -1 | Continuous strictly positive | ... |
| -2 | Continuous doubly bounded    | 1   |

** shapeout
|  0 | Continuous (real)            | ... |
|  1 | Int discrete ordinal         |   1 |
|  2 | Binary                       |   1 |
|  3 | Categorical                  |   1 |
| -1 | Continuous strictly positive | ... |
| -2 | Continuous doubly bounded    |   1 | concentration factor

** shapein
|  0 | Continuous (real)            | ... |
|  1 | Int discrete ordinal         |   1 |
|  2 | Binary                       |   1 |
|  3 | Categorical                  |  NA |
| -1 | Continuous strictly positive | ... |
| -2 | Continuous doubly bounded    |   1 |

** varscale (must be squared for variance)
|  0 | Continuous (real)            | ... |
|  1 | Int discrete ordinal         | 1/4 |
|  2 | Binary                       | NA  |
|  3 | Categorical                  | NA  |
| -1 | Continuous strictly positive | ... |
| -2 | Continuous doubly bounded    | 1/4 |


* Transformations

** For calculations x -> y
|  0 | Continuous (real)            | (x-mu)/si                 |
|  1 | Int discrete ordinal         | (x-mu)/si or (x-m)/si + 1 |
|  2 | Binary                       | (x-mu)/si                 |
|  3 | Categorical                  | (x-mu)/si                 |
| -1 | Continuous strictly positive | (log(x)-mu)/si            |
| -2 | Continuous doubly bounded    | qnorm((x-mu)/si)          |

** jacobians (to be multiplied)
|  0 | Continuous (real)            |                             1/si |
|  1 | Int discrete ordinal         |                                1 |
|  2 | Binary                       |                                1 |
|  3 | Categorical                  |                                1 |
| -1 | Continuous strictly positive |                         1/(si*x) |
| -2 | Continuous doubly bounded    | 1/(si*dnorm(y)) or 1 if y==bound |

** Inverses y -> x (when generating samples)
|  0 | Continuous (real)            | y*si + mu                             |
|  1 | Int discrete ordinal         | rinterval(length(y),y,bounds)*si + mu |
|  2 | Binary                       | y*si + mu                             |
|  3 | Categorical                  | y*si + mu                             |
| -1 | Continuous strictly positive | exp(y*si + mu)                        |
| -2 | Continuous doubly bounded    | pnorm(y*si + mu); y[y<=m] <- m; ...;  |



* Variate types:
** continuous (real)
*** unbounded
y <- qlogis((x-mu)/si)
mu <- 
*** semi-bounded
*** doubly bounded
** binary
** categorical







* Variate parameters
** integer
treated as real
good hyperparameters:

nint <- 16
dd <- 0.5/nint # pnorm(qnorm(0.5/nint))
tran <- function(x){qnorm(x*(1-2*dd)+dd)}
## dd <- 2^-11
##
nclusters <- 64
alphas <- c(1,2,0.5)
means <- c(0)
sds <- c(1)
shape1s <- c(2) # large scales
shape2s <- c(1) # small scales
scales <- 1/4^(-2) # inverse variance
##
xgrid <- seq(0,1,length.out=nint)
extr <- c(1,length(xgrid))
mgrid <- (xgrid[-extr[2]]+xgrid[-extr[1]])/2
mextr <- c(1,length(mgrid))
txgrid <- tran(xgrid)
tmgrid <- tran(mgrid)
##
pnorm(tmgrid[mextr[1]], m[i,acluster], s[i,acluster]) # first point
pnorm(tmgrid[-mextr[1]], m[i,acluster], s[i,acluster]) - pnorm(tmgrid[-mextr[2]], m[i,acluster], s[i,acluster]) # mid points
pnorm(tmgrid[mextr[2]], m[i,acluster], s[i,acluster], lower.tail=F) # last point

** continuous
*** type
0=unbounded, 1=semi-bounded, 2=doubly-bounded
*** location
*** scale
*** left bound
*** right bound
(these two decide the transformation function)
*** precision
(possibly connect this with integer values)
*** display min (left bound)
*** display max (right bound)

*** centre hyperparameter (meanRmean0)
*** spread hyperparameter (meanRvar0)
*** minwidth hyperparameter (varRshape2shape)
*** maxwidth hyperparameter (varRshape1)

*** data min
*** Q1
*** Q2 (median)
*** Q3
*** data max

** binary
*** location
min=0
*** scale

** binary, categorical
*** location
min=1
*** scale
*** left bound
*** right bound



* Positive
** transformation:
#+begin_src R
sd2iqr <- 0.5/qnorm(0.75)
  scaley <- sd2iqr * *** # log(Q3)-log(Q1)
  locationy <- *** # log(median)
tran <- function(x){(log(x)-location)/scale}
invtran <- function(y){exp(y*scale+location)}
jac <- function(x){1/(scale*x)}
#+end_src

** hyperparameters:
#+begin_src R
  mean0 <- 0
  sd0 <- 2
  shapemacro0 <- 1/2 # large scales, in outer inv-gamma
  shapemicro0 <- 1/2 # small scales, in inner inv-gamma
  iscale0 <- (1/4)^(-2) # in inner inv-gamma; dim=1/variance
#+end_src

** probability calculation:
#+begin_src R
  Y <- tran(X)
  dnorm(Y, mean[i,acluster], sd[i,acluster]) * jac(xgrid)
#+end_src




* Integers
** transformation:
#+begin_src R
  nI <- *** # number of values
  minI <- *** # min value
  maxI <- *** # max value
  scaley <- -qnorm(0.5/nI)
  locationx <- minI - 0.5*(maxI-minI)/(nI-1)
  scalex <- nI*(maxI-minI)/(nI-1)
  tran <- function(x){qnorm((x-locationx)/scalex)}
  invtran <- function(y){round(
  (scalex*pnorm(y)+locationx-minI)*(maxI-minI)/(nI-1)
  ) * (maxI-minI)/(nI-1)+minI}
#+end_src

** hyperparameters:
#+begin_src R
  mean0 <- 0
  sd0 <- 1
  shapemacro0 <- 1 # large scales, in outer inv-gamma
  shapemicro0 <- 1 # small scales, in inner inv-gamma
  iscale0 <- (1/8)^(-2) # in inner inv-gamma; dim=1/variance
#+end_src

** probability calculation:
#+begin_src R
  Y <- tran((X[-nI] + X[-1])/2)
  c(
    pnorm(Y[1], mean[i,acluster], sd[i,acluster]),
    pnorm(Y[-1], mean[i,acluster], sd[i,acluster]) -
    pnorm(Y[-nI], mean[i,acluster], sd[i,acluster]),
    pnorm(Y[nI], mean[i,acluster], sd[i,acluster], lower.tail=F)
  )
#+end_src

* Binary
** transformation:
#+begin_src R
tran <- function(x){x==***} # string
invtran <- function(y){if(x==1){***}else{***}} # strings
#+end_src

** hyperparameters:
#+begin_src R
  shapea0 <- 1
  shapeb0 <- 1
#+end_src

** probability calculation:
#+begin_src R
  Y <- tran(X)
  probB*X+(1-probB)*(1-X)
#+end_src


* Variates AD
Apoe4_		binary
Subgroup_num_		binary
Gender_num_		binary
GDTOTAL_gds		ordinal		0-6
AVDEL30MIN_neuro	ordinal		0-15
AVDELTOT_neuro	ordinal 	0-15
CATANIMSC_neuro	ordinal?	1-60 (number of words in 1 min)
ANARTERR_neuro	ordinal		0-50
RAVLT_immediate	ordinal		0-75 (5*15)
TRAASCOR_neuro	continuous	0-150 (bounded above)
TRABSCOR_neuro	continuous	0-300 (bounded above)
AGE			continuous	0-
LRHHC_n_long		continuous	0-






* Hyperparameters:
** continuous/integer:
mean0
meanvar0
shapemacro # in outer inv-gamma
shapemicro # in inner inv-gamma
scaleprec # in inner inv-gamma; dim=1/variance

location
scale

** binary
shape1=1
shape2=1

** categorical
calpha0 # 1/locvarMaxs[avar] or constant (1)


* Valuable hyperparameter settings
#+begin_src R
  ### see towards end for better parameters
  set.seed(222)
  #### Integer
  #### with norm transformation IV
  nint <- 32
  ## dd <- qnorm(0.5/nint)/2 + 0.5
  ## tran <- function(x){(x*(1-2*dd)+dd)*2-1}
  ## dd <- pnorm(qnorm(0.5/nint))
  ## tran <- function(x){qnorm(x*(1-2*dd)+dd)}
  ## invtran <- function(y){(pnorm(y)-dd)/(1-2*dd)}
  dd <- pnorm(qnorm(1/2/nint))
  tran <- function(x){qnorm(x*(1-2*dd)+dd)}
  ## invtran <- function(y){(pnorm(y)-dd)/(1-2*dd)}
  nmin <- 0
  nmax <- 1
  nsamples <- 400*8
  nsubsamples <- 400
  nclusters <- 64
  alphas <- c(1,2,0.5)
  means <- c(0)
  shapemeans <- c(256) # set to high value to mimick a delta, leading to gaussian for m
  scalemeans <- shapemeans * 1/1^2#1/1^2
  shape1s <- c(1) # large scales
  shape2s <- c(1) # small scales
  scalevars <- (1/8)^2
  ##
  alpha <- sample(rep(alphas,2),nsamples,replace=T)
  q <- extraDistr::rdirichlet(n=nsamples,alpha=matrix(alpha/nclusters,nsamples,nclusters))
  shapemean <- sample(rep(shapemeans,2),nsamples*nclusters,replace=T)
  scalemean <- sample(rep(scalemeans,2),nsamples*nclusters,replace=T)
  sd <- matrix(sqrt(nimble::rinvgamma(nsamples*nclusters,shape=shapemean,scale=scalemean)),nsamples)
  ## thist(log10(sd),plot=T)
  m <- matrix(rnorm(nsamples*nclusters,means,sd),nsamples)
  ## thist(m,plot=T)
  shape1 <- sample(rep(shape1s,2),nsamples*nclusters,replace=T)
  shape2 <- sample(rep(shape2s,2),nsamples*nclusters,replace=T)
  scalevar <- sample(rep(scalevars,2),nsamples*nclusters,replace=T)
  s <- matrix(sqrt(nimble::rinvgamma(nsamples*nclusters,shape=shape1,rate=nimble::rinvgamma(nsamples*nclusters,shape=shape2,rate=scalevar))),nsamples)
  ##
  graphics.off()
  pdff('samples_integer_normIV')
  par(mfrow=c(20,20),mar = c(0,0,0,0))
  xgrid <- seq(nmin,nmax,length.out=nint)
  extr <- c(1,length(xgrid))
  mgrid <- (xgrid[-extr[2]]+xgrid[-extr[1]])/2
  mextr <- c(1,length(mgrid))
  txgrid <- tran(xgrid)
  tmgrid <- tran(mgrid)
  ##
  ## even better
  nmin <- 0
  nmax <- nint-1
  dd <- pnorm(qnorm(1/2/nint))
  tran <- function(x){qnorm((x-nmin)/(nmax-nmin)*(1-2*dd)+dd)}
  ## invtran <- function(y){(pnorm(y)-dd)/(1-2*dd)}
  nsamples <- 400*8
  nsubsamples <- 400
  nclusters <- 64
  alphas <- c(1,2,0.5)
  means <- c(0)
  shapemeans <- c(512) # set to high value to mimick a delta, leading to gaussian for m
  scalemeans <- shapemeans * (7/8)^2#1/1^2
  shape1s <- c(1) # large scales
  shape2s <- c(1) # small scales
  scalevars <- (1/4)^2
#+end_src

#+begin_src R
#### Doubly-bounded case
#### with norm transformation @@@
sd2iqr <- 0.5/qnorm(0.75)
dt <- fread('~/repositories/ADBayes/worldbrain/ingrid_data_nogds6.csv')
varinfo <- read.csv('~/repositories/ADBayes/worldbrain/varinfo.csv',row.names=1)
graphics.off()
pdff('samples_doublybounded_norm_extr')
for(varindex in c('TRAASCOR_neuro','TRABSCOR_neuro')){
if(!is.na(varindex)){
    data <- dt[[varindex]]
}else{data <- NULL}
set.seed(123)
pdist <- pnorm
qdist <- qnorm
ddist <- dnorm
dd <- pdist(qnorm(2^-6)) # this is the amount of probability left in a tail
## tran <- function(x){qnorm(x*(1-2*dd)+dd)}
## jac <- function(x){1/dnorm(x*(1-2*dd)+dd)*(1-2*dd)}
xmin <- varinfo[varindex,'min']
xmax <- varinfo[varindex,'max']
xscale <- (xmax-xmin)/(1-2*dd)
xlocation <- xmin - dd*xscale
tran <- function(x){qdist((x-xlocation)/xscale)}
invtran <- function(y){pdist(y)*xscale+xlocation}
jac <- function(y){1/ddist(y)/xscale}
dx <- 1e-3
##
fract <- 400
nsamples <- fract*4
nclusters <- 64
alphas <- c(1,2,0.5)
means <- c(0)
sds <- c(1)
shape1s <- c(1) # large scales
shape2s <- c(1) # small scales
scales <- c(1/4)^-2
##
alpha <- sample(rep(alphas,2),nsamples,replace=T)
q <- extraDistr::rdirichlet(n=nsamples,alpha=matrix(alpha/nclusters,nsamples,nclusters))
sd <- sample(rep(sds,2),nsamples*nclusters,replace=T)
m <- matrix(rnorm(nsamples*nclusters,means,sd),nsamples)
shape1 <- sample(rep(shape1s,2),nsamples*nclusters,replace=T)
shape2 <- sample(rep(shape2s,2),nsamples*nclusters,replace=T)
scaleprec <- sample(rep(scales,2),nsamples*nclusters,replace=T)
s <- matrix(sqrt(nimble::rinvgamma(nsamples*nclusters,shape=shape1,rate=nimble::rinvgamma(nsamples*nclusters,shape=shape2,scale=scaleprec))),nsamples)
##
xgrid <- c(xmin,invtran(qdist(dd/8)),seq(xmin, xmax, length.out=256),invtran(qdist(1-dd/8)),xmax)
txgrid <- tran(xgrid)
extr <- c(1,length(xgrid))
extr2 <- c(2,length(xgrid)-1)
ysum <- 0
## tplot(x=xgrid,y=dnorm(txgrid)*jac(xgrid))
par(mfrow=c(20,20),mar = c(0,0,0,0))
for(i in 1:nsamples){
    y <- rowSums(sapply(1:nclusters,function(acluster){
        dens <- c(
            pnorm(txgrid[extr[1]], m[i,acluster], s[i,acluster]),
            dnorm(txgrid[-extr], m[i,acluster], s[i,acluster])*jac(txgrid[-extr]),
            pnorm(txgrid[extr[2]], m[i,acluster], s[i,acluster], lower.tail=F)
        )
        q[i,acluster]*dens}))
    ysum <- ysum+y
    if(i<fract | i==nsamples){
    if(i==nsamples){y <- ysum/nsamples}
    y[extr] <- y[extr] * max(y[-c(extr,extr2)],1/(xmax-xmin))
    if(!is.null(data)){
        his <- thist(data)
        ymax <- max(y,his$density)
    }else{ymax <- NULL}
    tplot(x=xgrid[-c(extr,extr2)], y=y[-c(extr,extr2)],
          ylim=c(0,max(y[-c(extr,extr2)],1/(xmax-xmin),ymax)),xlim=range(xgrid[-extr2]),
          xlabels=NA,ylabels=NA, xlab=NA,ylab=NA,
          xticks=NA,yticks=NA,
          mar=c(1,1,1,1)*0.5,
          col=if(i<fract){1}else{if(any(is.infinite(ysum))){2}else{3}}, ly=1,lwd=0.5)
    ## tplot(x=xgrid[extr2], y=y[extr2],
    ##       type='p',col=4,cex=0.15,add=T,pch=3)
    if(!is.null(data)){
        tplot(x=his$mids,y=his$density,type='l',lwd=0.5,add=T,alpha=0.25,col=4)
    }
    tplot(x=xgrid[extr+c(2,-2)], y=y[extr+c(2,-2)],
          type='p',col=4,cex=0.075,add=T,pch=1)
    tplot(x=xgrid[extr], y=y[extr],
          type='p',cex=0.1,col=1,add=T,pch=3)
    abline(h=c(0),lwd=0.5,col=alpha2hex(0.5,c(7,2)),lty=c(1,2))
    if(i==nsamples){
        abline(h=c(1/(xmax-xmin)),lwd=0.5,col=alpha2hex(0.5,c(2)),lty=1)
    }
    abline(v=c(xmin,xmax),lwd=0.5,col=alpha2hex(0.5,7),lty=2)
    }
}
}
dev.off()
#+end_src
